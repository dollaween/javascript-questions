# Javascript-вопросы: Общее



---
















##### 7. Что такое стек вызовов (call stack)?
<details><summary><b>Ответ</b></summary>
<p>

**Стек** __(простыми словами)__ — это простая структура данных, которая работает по принципу «last in — first out», т.е. «последнего положил — его же первого достаешь».

**Стек вызовов (call stack)** — это механизм для интерпретатора для отслеживания текущего местонахождения интерпретатора в скрипте, который вызывает несколько функций типа `functions` — какая из функций выполняется на данный момент, какие функции вызываются изнутри этой (выполняемой) функции, какая будет вызвана следующей и т. д.
* Когда скрипт вызывает функцию, интерпретатор добавляет ее в стек вызовов и потом начинает ее обработку.
* Любые функции, вызванные этой функцией, добавляются в стек вызовов и выполняются, как только происходит их вызов.
* Когда выполнение основной функции завершено, интерпретатор снимает ее со стека вызовов и возобновляет выполнение кода в списке основного кода с той точки, где остановился до этого.
* Если стек занимает больше места, чем ему было присвоено, это приводит к ошибке переполнения стека (`stack overflow` error).

</p>
</details>



---



##### 8. Что такое частичное применение функций?
<details><summary><b>Ответ</b></summary>
<p>

**Частичное применение функций** — предоставление функции с меньшим количеством аргументов, чем она ожидает.

[Частичное применение функций](https://medium.com/devschacht/functional-reactive-ninja-partial-application-of-functions-99fc21d629ff)

</p>
</details>



---



##### 9. Что такое цепь вызовов (method chaining)?
<details><summary><b>Ответ</b></summary>
<p>

**Цепь вызовов** — конструкция, при которой вызов одного метода следует сразу за вызовом другого.

```js
'Hello'.replace(/Hello/g, 'Bye').concat('!')
```

</p>
</details>



---



##### 10. Что такое LHS и RHS поиск движка?
<details><summary><b>Ответ</b></summary>
<p>

**LHS (Left Hand Side)** — левосторонний поиск по отношению к оператору `=`.

**RHS (Right Hand Side)** — правосторонний поиск по отношению к оператору `=`.

В зависимости от того, какую ссылку мы ищем, RHS или LHS, могут быть разные результаты.

Если был RHS поиск и переменная не найдена, то мы получим `ReferenceError`.

Если был RHS поиск, переменная найдена, но мы пытаемся сделать с ней что-то противоестественное (например, использовать не функцию, как функцию), то мы получим `TypeError`.

Если был LHS поиск и переменная не найдена: При `StrictMode` мы получим `ReferenceError`, в ином случае в глобальной области будет создана переменная с указанным именем и передана движку.

```js
console.log(a)      // RHS
a = 2               // LHS

function foo(a) {
  console.log(a)
}

foo(2)
// RHS при вызове foo()
// LHS при присваивании аргументу `a` значение `2`
```

[Вы не знаете JS. Области видимости и замыкания. Часть 1](https://medium.com/@Dimetrio89/вы-не-знаете-js-область-видимости-и-замыкания-часть-1-17f305c79785)

</p>
</details>



---



##### 11. Что такое куча (Memory heap)?
<details><summary><b>Ответ</b></summary>
<p>

**Куча (Memory heap)** — имя для обозначения большой неструктурированной области памяти.

</p>
</details>



---



##### 12. Что такое цикл событий (event loop) и какой у него алгоритм работы?
<details><summary><b>Ответ</b></summary>
<p>

**Цикл событий (event loop)** — это бесконечный цикл, в котором движок Javascript ожидает задачи, исполняет их и снова ожидает появление новых задач.

Алгоритм работы Event loop по стандарту `whatwg`:
1. Выбрать свободную таску из очереди
2. Выполнить её
3. Выполнить микрозадачи
4. Обновить рендеринг (если необходимо)

</p>
</details>



---



##### 13. Что такое макрозадачи и микрозадачи?
<details><summary><b>Ответ</b></summary>
<p>

Макрозадача (или `task`) — задача, которая выполняется за один цикл Event Loop. За один цикл Event Loop выполняется только одна макрозадача.

Существует два типа макрозадач:
- `CPU bound` — циклы, методы прохода массивов, JSON.parse, JSON.stringify, подсчет хэшей
- `I/O bound` — таймаут, xhr/fetch, сеть (бд), файл

Микрозадачи (или `microtasks`) — задачи, которые выполняются сразу после макрозадачи и очистки стека.
- После каждой макрозадачи выполняются сразу все микрозадачи, которые есть в очереди
- Микрозадачи могут порождать новые микрозадачи в процессе, поэтому с этим нужно быть осторожнее, чтобы не заблокировать Event loop

Источники микрозадач:
- `Promise.then`, `await`
- `Mutation observer`
- `Object.observe` (deprecated)
- Специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач

[Иван Тулуп: асинхронщина в JS под капотом](https://habr.com/ru/company/oleg-bunin/blog/417461/)

</p>
</details>



---



##### 14. Какие есть side-эффекты при исполнении микрозадач?
<details><summary><b>Ответ</b></summary>
<p>

Так как микрозадачи исполняются в конце очистки стека, то возможны side-эффекты, когда пользовательское поведение будет исполнено иначе, чем прямой вызов функции.

Пример:

```js
const container = document.getElementById('container');
const button = document.getElementById('button')

button.addEventListener('click', () => {
  Promise.resolve()
    .then(() => console.log('RO'))

  console.log('FUS')
})

container.addEventListener('click', () => {
  console.log('DAH')
})
```

У нас есть кнопка `button`, вложенная в div `container`.

При клике на `button` в консоль будет выведено по очереди: `FUS`, `RO`, `DAH`.

Если в конце этого кода добавить строчку:

```js
button.click()
```

То теперь в консоль будет выведено: `FUS`, `DAH`, `RO`.

Разберем причину такого поведения:
1. Выполняется `button.click()`. Мы кладем его в стек
2. Переходим в `handleClick` button-а
3. Выполняем `Promise.resolve`. Он добавляет нам микротаску `then` в очередь. `Promise.resolve` исполняется
4. Далее переходим в `console.log` и выводим `FUS`
5. Мы закончили тело `handleClick` button-а и выходим из него, снимаем его со стека. Но наш синхронный код (click) не закончился, потому что есть другие хендлеры и стек не очищен
6. Переходим в `handleClick` container-а и выводим в `console.log` `DAH`
7. Стек очистился, исполняется микротаска `then` и в `console.log` выводится `RO`

Решение проблемы: использовать `stopPropagation`

Пример взят из:
[Иван Тулуп: асинхронщина в JS под капотом](https://habr.com/ru/company/oleg-bunin/blog/417461)

</p>
</details>



---



##### 15. В чем отличие `Event loop` в браузере и `Node.js`?
<details><summary><b>Ответ</b></summary>
<p>

`Event loop` в `Node.js` четко расписан по фазам:
1. `timers`
2. `pending callback`
3. `idle, prepare`
4. `poll`
5. `check`
6. `close callbacks`

В браузерах `Event loop` устроен по разному, в зависимости от браузера.

</p>
</details>



---




