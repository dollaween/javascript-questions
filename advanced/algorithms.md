<div align="center">

# Вопросы по алгоритмам

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)

</div>

---

##### 1. Чем паттерн отличается от алгоритма?

<details><summary><b>Ответ</b></summary>
<p>

**Алгоритм** — это четкий набор действий.

**Паттерн** — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

</p>
</details>

---

##### 2. Что такое нотация О большое (Big O notation)?

<details><summary><b>Ответ</b></summary>
<p>

Нотация О большое — это математическая нотация, которая описывает ограничивающее поведение функции, когда аргумент стремится к определенному значению или бесконечности. Проще говоря, нотация О большое описывает **худший вариант сложности** написанного кода с использованием алгебраических терминов.

Концепцию О большое необходимо понимать, чтобы уметь видеть и исправлять неоптимальный код.

##### Отбрасывание констант
Big O описывает только темп роста функции, поэтому мы отбрасываем константы при оценке сложности:
* `O(2N)` должен описываться как `O(N)`
* `O(500) = O(1)`
* `O(N/2) = O(N)`
* `O(N^2 + 100) = O(N^2)`

##### Неважная сложность
Мы можем сокращать описание сложности, убирая из формулы неважную сложность. Неважной считается сложность, которая значительно меньше уже имеющейся сложности (где значительно — это минимум в 2 раза)
* `O(N^2 + N^2) = O(N^2)`
* `O(N^2 + N) = O(N^2)` — так как `N` значительно меньше чем `N^2`
* `O(N + log N) = O(N)`, так как `log N` значительно меньше чем `N`
* `O(5 * 2^N + 10 * N^100) = O(2^N)`
* `O(N^2 + B) = O(N^2 + B)` — не может быть сокращено, так как мы не знаем что такое `B`

##### Складывать или умножать сложность?
Если действия выполняются последовательно — то складываем:
```js
for (int a: arrA) {}
for (int b: arrB) {}
// O(A + B)
```

Если действия зависимы друг от друга — то умножаем:
```js
for (int a: arrA) {
  for (int b: arrB) {}
}
// O(A * B)
```

##### Про сложность `log N`
Для алгоритмов, где на каждой итерации берется половина элементов — сложность будет включать `O(log N)` (включать, но не обязательно равняться).

##### Примеры сложности по убыванию
1. N!
2. 2^N
3. N^2
4. N * log N
5. N
6. Квадратный корень из N
7. log N
8. 1

##### Сложность Big O для базовых действий

Объекты:
* Взятие по ключу — `O(1)`
* Запись — `O(1)`
* Удаление — `O(1)`
* Поиск (не ключа, а значения где бы то ни было в объекте) — `O(N)`
* `Object.keys()` — `O(N)`
* `Object.values()` — `O(N)`
* `hasOwnProperty` — `O(1)`

Массивы:
* push — амортизированное `O(1)`, т.е. в большинстве случаев `O(1)`, в редких худших случаях `O(N)` (когда память под массив закончилась, интерпретатор создает новый массив с большим количеством памяти и копирует туда текущий)
* pop — `O(1)`
* shift, unshift — `O(N)`
* concat, slice, splice — `O(N)`
* sort — `O(N * log N)`
* find, includes, indexOf — `O(N)`
* forEach, map, reduce, filter, ... — `O(N)`

Map / Set:
* set — амортизированное `O(1)` или `O(log N)`
* delete — амортизированное `O(1)` или `O(log N)`
* get, has — амортизированное `O(1)` или `O(log N)`
* keys, values, entries — `O(N)`

DOM дерево:
* appendChild, insertBefore — `O(1)`
* removeChild — `O(1)`
* getElementById — `O(1)`
* getElementsByClassName — `O(N)`
* querySelector, querySelectorAll — `O(N)`

</p>
</details>

---

##### 3. Что такое пространственная сложность (Space complexity)?

<details><summary><b>Ответ</b></summary>
<p>

**Пространственная сложность** — один из критериев оценки алгоритмов, который показывает зависимость количества занимаемой памяти от размера входных данных.

</p>
</details>


---

##### 4. Как работает и какие задачи решает паттерн Frequency Counter?

<details><summary><b>Ответ</b></summary>
<p>

**Frequency Counter** — это паттерн, использующий объекты для хранения значений/частотности значений. Позволяет избежать квадратичной сложности O(N^2) вложенных циклов или операций с массивами/строками.

Подходит для:
* Подсчета частоты значений массива
* Вычисления содержания значений одного массива `arr1` в другом `arr2` (включая видоизмененные значения)
* Поиск нескольких значений в массиве `arr`, которые в совокупности дадут целевое значение `target`

```js
fn(arr)
fn(arr1, arr2)
fn(arr, target)
```

#### Реализация 1:
Реализация преимущественно используется при наличии двух массивов:
1. Создайте пустой объект `freqCounter`.
2. Пройдитесь по массиву, записав частотность (или другие нужные данные) в ключи `freqCounter`.
3. Пройдитесь по второму массиву, сравнив значения с ключами `freqCounter`.

Так как частотность хранится в ключах объекта `freqCounter`, то доступ к этим ключам мы получаем с константной сложностью O(N). В итоге мы проходимся по массиву два раза со сложностью O(N), вместо вложенных циклов со сложностью O(N^2).

#### Реализация 2:
Реализация преимущественно используется при наличии одного массива:
1. Создайте пустой объект `freqCounter`.
2. Пройдитесь по массиву, на каждой итерации записывая частотность в ключи `freqCounter` и сразу же сравниваия значения массива с ключами `freqCounter`.

#### Пример 1:
Пример первого вида реализации:

Напишите функцию, которая принимает два массива чисел и возвращает true, если второй массив содержит те же числа, но в квадрате (порядок чисел значения не имеет).

```js
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false
  }

  let freqCounter = {}

  for (let val of arr1) {
    let squared = val ** 2
    freqCounter[squared] = (freqCounter[squared] || 0) + 1
  }

  for (let val of arr2) {
    if (!freqCounter[val]) {
      return false
    }
    freqCounter[val] -= 1
  }

  return true
}
```

#### Пример 2:
Пример второго вида реализации:

Напишите функцию, которая принимает массив чисел `nums` и число `target`. Функция должна найти и вернуть индексы двух чисел, сумма которых равна числу `target`.

```js
function twoSum(nums, target) {
  const freqCounter = {}

  for (let i = 0; i < nums.length; i++) {
    const cur = freqCounter[nums[i]]

    if (cur >= 0) {
      return [cur, i]
    } else {
      const numToFind = target - nums[i]
      freqCounter[numToFind] = i
    }
  }

  return null
}
```

</p>
</details>

---

##### 5. Как работает и какие задачи решает паттерн Multiple Pointers?

<details><summary><b>Ответ</b></summary>
<p>

**Multiple Pointers** — это паттерн, при котором создаются несколько указателей, соответствующих индексу или позиции, и двигающихся по направлению к началу/концу/середине от начальной позиции. Паттерн крайне эффективен для решения задач с минимальной простраственной сложностью (space complexity).

Подходит для:
* Сравнивания/использования значений массива начиная одновременно из начала и конца
* Слияния двух отсортированных массивов в один отсортированный

#### Реализация 1
При наличии одного массива:
0. При надобности — отсортируйте массив.
1. Создайте несколько указателей с начальными позициями.
2. Пройдитесь по массиву, в каждой итерации изменяя указатели.

#### Реализация 2
При наличии двух массивов:
0. При надобности — отсортируйте массивы.
1. Создайте два указателя — один для первого массива, другой для второго.
2. В каждой итерации изменяйте указатели (либо один из указателей в зависимости от условия)

#### Пример
Напишите фукнцию, которая принимает отсортированный массив чисел numbers. Функция должна найти и вернуть первую пару чисел, сумма которых равна нулю.

```javascript
function sumZero(numbers) {
  let left = 0
  let right = numbers.length - 1

  while (left < right) {
    let sum = numbers[left] + numbers[right]

    if (sum === 0) return [numbers[left], numbers[right]]
    else if (sum < 0) left++
    else right--
  }
}
```

</p>
</details>

---

Источники:
* [Алгоритмы и структуры данных — Артём Вурсалов](https://youtu.be/ijwbVxLMp58)
* [Оценка сложности алгоритма. Сложность алгоритмов. Big O, Большое О](https://youtu.be/ZRdOb4yR0kk)
