<div align="center">

# Вопросы по алгоритмам

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)

</div>

---

##### 1. Чем паттерн отличается от алгоритма?

<details><summary><b>Ответ</b></summary>
<p>

**Алгоритм** — это четкий набор действий.

**Паттерн** — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

</p>
</details>

---

##### 2. Что такое нотация О большое (Big O notation)?

<details><summary><b>Ответ</b></summary>
<p>

Нотация О большое — это математическая нотация, которая описывает ограничивающее поведение функции, когда аргумент стремится к определенному значению или бесконечности. Проще говоря, нотация О большое описывает **худший вариант сложности** написанного кода с использованием алгебраических терминов.

Концепцию О большое необходимо понимать, чтобы уметь видеть и исправлять неоптимальный код.

##### Отбрасывание констант
Big O описывает только темп роста функции, поэтому мы отбрасываем константы при оценке сложности:
* `O(2N)` должен описываться как `O(N)`
* `O(500) = O(1)`
* `O(N/2) = O(N)`
* `O(N^2 + 100) = O(N^2)`

##### Неважная сложность
Мы можем сокращать описание сложности, убирая из формулы неважную сложность. Неважной считается сложность, которая значительно меньше уже имеющейся сложности (где значительно — это минимум в 2 раза)
* `O(N^2 + N^2) = O(N^2)`
* `O(N^2 + N) = O(N^2)` — так как `N` значительно меньше чем `N^2`
* `O(N + log N) = O(N)`, так как `log N` значительно меньше чем `N`
* `O(5 * 2^N + 10 * N^100) = O(2^N)`
* `O(N^2 + B) = O(N^2 + B)` — не может быть сокращено, так как мы не знаем что такое `B`

##### Складывать или умножать сложность?
Если действия выполняются последовательно — то складываем:
```js
for (int a: arrA) {}
for (int b: arrB) {}
// O(A + B)
```

Если действия зависимы друг от друга — то умножаем:
```js
for (int a: arrA) {
  for (int b: arrB) {}
}
// O(A * B)
```

##### Про сложность `log N`
Для алгоритмов, где на каждой итерации берется половина элементов — сложность будет включать `O(log N)` (включать, но не обязательно равняться).

##### Примеры сложности по убыванию
1. N!
2. 2^N
3. N^2
4. N * log N
5. N
6. Квадратный корень из N
7. log N
8. 1

##### Сложность Big O для базовых действий

Объекты:
* Доступ — `O(1)`
* Вставка — `O(1)`
* Удаление — `O(1)`
* Поиск (не ключа, а значения где бы то ни было в объекте) — `O(N)`
* `Object.keys()` — `O(N)`
* `Object.values()` — `O(N)`
* `hasOwnProperty` — `O(1)`

Массивы:
* push, pop — `O(1)`
* shift, unshift — `O(N)`
* concat, slice, splice — `O(N)`
* sort — `O(N * log N)`
* forEach, map, reduce, filter, ... — `O(N)`

Источники:
* [Оценка сложности алгоритма. Сложность алгоритмов. Big O, Большое О](https://www.youtube.com/watch?v=ZRdOb4yR0kk&ab_channel=CronisAcademy)

</p>
</details>

---

##### 3. Как работает и какие задачи решает паттерн Frequency Counter?

<details><summary><b>Ответ</b></summary>
<p>

**Frequency Counter** — это паттерн, использующий объекты для хранения значений/частотности значений. Позволяет избежать квадратичной сложности O(N^2) вложенных циклов или операций с массивами/строками.

#### Реализация:
1. Создать пустой объект `freqCounter`.
2. Пройтись по массиву, записав частотность (или другие нужные данные) в ключи `freqCounter`.
3. Пройтись по массиву еще раз, сравнив значения массива с ключами `freqCounter`.

Так как частотность хранится в ключах объекта `freqCounter`, то доступ к этим ключам мы получаем с константной сложностью O(N). В итоге мы проходимся по массиву два раза со сложностью O(N), вместо вложенных циклов со сложностью O(N^2).

#### Реализация 2:
1. Создать пустой объект `freqCounter`.
2. Пройтись по массиву, на каждой итерации записывая частотность в ключи `freqCounter` и сразу же сравниваия значения массива с ключами `freqCounter`.

Получается та же самая реализация, но с одним циклом прогона массива.

</p>
</details>
