<div align="center">

# Вопросы по алгоритмам

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)

</div>

---

##### 1. Чем паттерн отличается от алгоритма?

<details><summary><b>Ответ</b></summary>
<p>

**Алгоритм** — это четкий набор действий.

**Паттерн** — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

</p>
</details>

---

##### 2. Что такое нотация О большое (Big O notation)?

<details><summary><b>Ответ</b></summary>
<p>

Нотация О большое — это математическая нотация, которая описывает ограничивающее поведение функции, когда аргумент стремится к определенному значению или бесконечности. Проще говоря, нотация О большое описывает **худший вариант сложности** написанного кода с использованием алгебраических терминов.

Концепцию О большое необходимо понимать, чтобы уметь видеть и исправлять неоптимальный код.

##### Отбрасывание констант
Big O описывает только темп роста функции, поэтому мы отбрасываем константы при оценке сложности:
* `O(2N)` должен описываться как `O(N)`
* `O(500) = O(1)`
* `O(N/2) = O(N)`
* `O(N^2 + 100) = O(N^2)`

##### Неважная сложность
Мы можем сокращать описание сложности, убирая из формулы неважную сложность. Неважной считается сложность, которая значительно меньше уже имеющейся сложности (где значительно — это минимум в 2 раза)
* `O(N^2 + N^2) = O(N^2)`
* `O(N^2 + N) = O(N^2)` — так как `N` значительно меньше чем `N^2`
* `O(N + log N) = O(N)`, так как `log N` значительно меньше чем `N`
* `O(5 * 2^N + 10 * N^100) = O(2^N)`
* `O(N^2 + B) = O(N^2 + B)` — не может быть сокращено, так как мы не знаем что такое `B`

##### Складывать или умножать сложность?
Если действия выполняются последовательно — то складываем:
```js
for (int a: arrA) {}
for (int b: arrB) {}
// O(A + B)
```

Если действия зависимы друг от друга — то умножаем:
```js
for (int a: arrA) {
  for (int b: arrB) {}
}
// O(A * B)
```

##### Про сложность `log N`
Для алгоритмов, где на каждой итерации берется половина элементов — сложность будет включать `O(log N)` (включать, но не обязательно равняться).

##### Примеры сложности по убыванию
1. N!
2. 2^N
3. N^2
4. N * log N
5. N
6. Квадратный корень из N
7. log N
8. 1

##### Сложность Big O для базовых действий

Объекты:
* Доступ — `O(1)`
* Вставка — `O(1)`
* Удаление — `O(1)`
* Поиск (не ключа, а значения где бы то ни было в объекте) — `O(N)`
* `Object.keys()` — `O(N)`
* `Object.values()` — `O(N)`
* `hasOwnProperty` — `O(1)`

Массивы:
* push, pop — `O(1)`
* shift, unshift — `O(N)`
* concat, slice, splice — `O(N)`
* sort — `O(N * log N)`
* forEach, map, reduce, filter, ... — `O(N)`

Источники:
* [Оценка сложности алгоритма. Сложность алгоритмов. Big O, Большое О](https://www.youtube.com/watch?v=ZRdOb4yR0kk&ab_channel=CronisAcademy)

</p>
</details>

---

##### 3. Как работает и какие задачи решает паттерн Frequency Counter?

<details><summary><b>Ответ</b></summary>
<p>

**Frequency Counter** — это паттерн, использующий объекты для хранения значений/частотности значений. Позволяет избежать квадратичной сложности O(N^2) вложенных циклов или операций с массивами/строками.

Подходит для:
* Подсчета частоты значений массива
* Вычисления содержания значений одного массива `arr1` в другом `arr2` (включая видоизмененные значения)
* Поиск нескольких значений в массиве `arr`, которые в совокупности дадут целевое значение `target`

```js
fn(arr)
fn(arr1, arr2)
fn(arr, target)
```

#### Реализация 1:
Реализация преимущественно используется при наличии двух массивов:
1. Создать пустой объект `freqCounter`.
2. Пройтись по массиву, записав частотность (или другие нужные данные) в ключи `freqCounter`.
3. Пройтись по второму массиву, сравнив значения с ключами `freqCounter`.

Так как частотность хранится в ключах объекта `freqCounter`, то доступ к этим ключам мы получаем с константной сложностью O(N). В итоге мы проходимся по массиву два раза со сложностью O(N), вместо вложенных циклов со сложностью O(N^2).

#### Реализация 2:
Реализация преимущественно используется при наличии одного массива:
1. Создать пустой объект `freqCounter`.
2. Пройтись по массиву, на каждой итерации записывая частотность в ключи `freqCounter` и сразу же сравниваия значения массива с ключами `freqCounter`.

#### Пример 1:
Пример первого вида реализации:

Напишите функцию, которая принимает два массива чисел и возвращает true, если второй массив содержит те же числа, но в квадрате (порядок чисел значения не имеет).

```js
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false
  }

  let freqCounter = {}

  for (let val of arr1) {
    let squared = val ** 2
    freqCounter[squared] = (freqCounter[squared] || 0) + 1
  }

  for (let val of arr2) {
    if (!freqCounter[val]) {
      return false
    }
    freqCounter[val] -= 1
  }

  return true
}
```

#### Пример 2:
Пример второго вида реализации:

Напишите функцию, которая принимает массив чисел `nums` и число `target`. Функция должна найти и вернуть индексы двух чисел, сумма которых равна числу `target`.

```js
function twoSum(nums, target) {
  const freqCounter = {}

  for (let i = 0; i < nums.length; i++) {
    const cur = freqCounter[nums[i]]

    if (cur >= 0) {
      return [cur, i]
    } else {
      const numToFind = target - nums[i]
      freqCounter[numToFind] = i
    }
  }

  return null
}
```

</p>
</details>
