<div align="center">

# Вопросы по ядру JS

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)

</div>

---

##### 1. Javascript компилируемый или интерпретируемый язык?
<details><summary><b>Ответ</b></summary>
<p>

Javascript интерпретируемый язык.

**Компилируемые языки** — исходный код преобразуется компилятором в машинный код и записывается в файл. Код компилируется до выполнения.

Преимущества:
- Код оптимизирован максимально для той системы, под которую скомпилирован.

Недостатки:
- При смене системы, если нет исходников — мы теряем программу.

**Интерпретируемые языки** — исходный код исполняется программой-интерпретатором.

Преимущества:
- Легко достичь кросс-платформенности

</p>
</details>

---

##### 2. Что такое контекст выполнения (Execution context)? Как JS-движок создает и управляет контекстом выполнения?
<details><summary><b>Ответ</b></summary>
<p>

**Контекст выполнения (Execution context)** — это концепция, описывающая окружение, в котором производится выполнение кода на JS.

Существует три типа контекстов:
1. Глобальный контекст выполнения — это базовый, используемый по умолчанию контекст выполнения. Если код находится не внутри функции, значит он принадлежит глобальному контексту.
2. Контекст выполнения функции. Каждый раз, когда вызывается функция, для нее создается новый контекст. Каждая функция имеет собственный контекст выполнения.
3. Контекст выполнения функции `eval`.

Стадия создания контекста выполнения:
1. Определяется значение `this` и выполняется привязка `this`.
2. Создается компонент LexicalEnvironment (лексическое окружение).
3. Создается компонент VariableEnvironment (окружение переменных).

Управление контекстом выполнения:
1. Движок создает глобальный контекст выполнения и помещает его в **стек вызовов (call stack)**.
2. При обнаружении команды вызова функции движок создает новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.
3. Движок выполняет функцию, контекст выполнения которой находится в верхней части стека вызовов.
4. Когда выполнение функции завершится, её контекст извлекается из стека и управление переходит тому контексту, который находится в предыдущем элементе стека.

</p>
</details>

---

##### 3. Что такое `this`? Как происходит привязка `this`?

<details><summary><b>Ответ</b></summary>
<p>

`this` — это ключевое слово, которое содержит ссылку на некоторый объект.

В глобальном контексте выполнения `this` содержит ссылку на глобальный объект.

В контексте выполнения функции значение `this` зависит от того, как именно была вызвана функция.
Если она вызвана в виде метода объекта, тогда значение `this` привязано к этому объекту:
```js
const myObject = {
  method() {
    console.log(this)
  }
}

myObject.method() // myObject
```

При создании функции через конструктор, `this` устанавливается на область видимости этой функции:
```js
function MyFunction() {
  console.log(this)
}
new MyFunction() // MyFunction
```

При косвенных вызовах функции через `myFunc.call()` или `myFunc.apply()` значение `this` эквивалентно первому аргументу.

В других случаях `this` привязывается к глобальному объекту или устанавливается в `undefined` (в строгом режиме).

</p>
</details>

---

##### 4. Что такое лексическое окружение?
<details><summary><b>Ответ</b></summary>
<p>

**Лексическое окружение** — это структура, которая хранит сведения о соответствии идентификаторов (имя переменной) и переменных (ссылка на конкретный объект или примитивное значение).

В лексическом окружении имеется два компонента:
1. **Запись окружения (Environment Record)** — объект, в котором как свойства хранятся все локальные переменные (а также значение this).
2. Ссылка на внешнее лексическое окружение, наличие которой говорит о доступе к родительскому лексическому окружению.

Существует три типа лексических окружений:
1. Глобальное окружение — это лексическое окружение, у которого ссылка на внешнее окружение равно `null`.
2. Окружение функции.
3. Окружение блока кода.

</p>
</details>

---

##### 5. Что такое переменная?

<details><summary><b>Ответ</b></summary>
<p>

**Переменная** — это свойство объекта **Environment Record**.

**Получить/изменить переменную** — означает получить/изменить свойство этого объекта.

</p>
</details>

---

##### 6. Что такое стек вызовов (Call Stack)?
<details><summary><b>Ответ</b></summary>
<p>

**Стек** __(простыми словами)__ — это простая структура данных, которая работает по принципу «last in — first out», т.е. «последнего положил — его же первого достаешь».

**Стек вызовов (call stack)** — это механизм для интерпретатора для отслеживания текущего местонахождения интерпретатора в скрипте, который вызывает несколько функций типа `functions` — какая из функций выполняется на данный момент, какие функции вызываются изнутри этой (выполняемой) функции, какая будет вызвана следующей и т. д.
* Когда скрипт вызывает функцию, интерпретатор добавляет ее в стек вызовов и потом начинает ее обработку.
* Любые функции, вызванные этой функцией, добавляются в стек вызовов и выполняются, как только происходит их вызов.
* Когда выполнение основной функции завершено, интерпретатор снимает ее со стека вызовов и возобновляет выполнение кода в списке основного кода с той точки, где остановился до этого.
* Если стек занимает больше места, чем ему было присвоено, это приводит к ошибке переполнения стека (`stack overflow` error).

</p>
</details>

---

##### 7. Что такое цикл событий (Event Loop) и какой у него алгоритм работы?
<details><summary><b>Ответ</b></summary>
<p>

**Цикл событий (Event Loop)** — это бесконечный цикл, в котором движок Javascript ожидает задачи, исполняет их и снова ожидает появление новых задач.

Алгоритм работы Event Loop по стандарту `whatwg`:
1. Выбрать свободную таску из очереди
2. Выполнить её
3. Выполнить микрозадачи
4. Обновить рендеринг (если необходимо)

</p>
</details>

---

##### 8. Что такое макрозадачи и микрозадачи?
<details><summary><b>Ответ</b></summary>
<p>

Макрозадача (или `task`) — задача, которая выполняется за один цикл Event Loop. За один цикл Event Loop выполняется только одна макрозадача.

Существует два типа макрозадач:
- `CPU bound` — циклы, методы прохода массивов, JSON.parse, JSON.stringify, подсчет хэшей
- `I/O bound` — таймаут, xhr/fetch, сеть (бд), файл

Микрозадачи (или `microtasks`) — задачи, которые выполняются сразу после макрозадачи и очистки стека.
- После каждой макрозадачи выполняются сразу все микрозадачи, которые есть в очереди
- Микрозадачи могут порождать новые микрозадачи в процессе, поэтому с этим нужно быть осторожнее, чтобы не заблокировать Event loop

Источники микрозадач:
- `Promise.then`, `await`
- `Mutation observer`
- `Object.observe` (deprecated)
- Специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач

[Иван Тулуп: асинхронщина в JS под капотом](https://habr.com/ru/company/oleg-bunin/blog/417461/)

</p>
</details>

---

##### 9. Какие есть side-эффекты при исполнении микрозадач?
<details><summary><b>Ответ</b></summary>
<p>

Так как микрозадачи исполняются в конце очистки стека, то возможны side-эффекты, когда пользовательское поведение будет исполнено иначе, чем прямой вызов функции.

Пример:

```js
const container = document.getElementById('container');
const button = document.getElementById('button')

button.addEventListener('click', () => {
  Promise.resolve()
    .then(() => console.log('RO'))

  console.log('FUS')
})

container.addEventListener('click', () => {
  console.log('DAH')
})
```

У нас есть кнопка `button`, вложенная в div `container`.

При клике на `button` в консоль будет выведено по очереди: `FUS`, `RO`, `DAH`.

Если в конце этого кода добавить строчку:

```js
button.click()
```

То теперь в консоль будет выведено: `FUS`, `DAH`, `RO`.

Разберем причину такого поведения:
1. Выполняется `button.click()`. Мы кладем его в стек
2. Переходим в `handleClick` button-а
3. Выполняем `Promise.resolve`. Он добавляет нам микротаску `then` в очередь. `Promise.resolve` исполняется
4. Далее переходим в `console.log` и выводим `FUS`
5. Мы закончили тело `handleClick` button-а и выходим из него, снимаем его со стека. Но наш синхронный код (click) не закончился, потому что есть другие хендлеры и стек не очищен
6. Переходим в `handleClick` container-а и выводим в `console.log` `DAH`
7. Стек очистился, исполняется микротаска `then` и в `console.log` выводится `RO`

Решение проблемы: использовать `stopPropagation`

Пример взят из:
[Иван Тулуп: асинхронщина в JS под капотом](https://habr.com/ru/company/oleg-bunin/blog/417461)

</p>
</details>

---

##### 10. В чем отличие Event Loop в браузере и Node.js?
<details><summary><b>Ответ</b></summary>
<p>

`Event Loop` в `Node.js` четко расписан по фазам:
1. `timers`
2. `pending callback`
3. `idle, prepare`
4. `poll`
5. `check`
6. `close callbacks`

В браузерах `Event Loop` устроен по-разному, в зависимости от браузера.

</p>
</details>

---

##### 11. Что такое куча (Memory Heap)?
<details><summary><b>Ответ</b></summary>
<p>

**Куча (Memory Heap)** — имя для обозначения большой неструктурированной области памяти.

</p>
</details>

---

##### 12. Что такое утечка памяти? Какие виды утечек памяти есть и как с ними бороться?

<details><summary><b>Ответ</b></summary>
<p>

**Утечка памяти** — память, которая больше не требуется приложению, но по какой-то причине не возвращается операционной системе или куче.

Утечки памяти случаются из-за:
* Создания случайных глобальных переменных
* Забытых таймеров, обработчиков событий и коллбэков
* Ссылок на удаленные из DOM элементы
* Замыканий

Как бороться с утечками памяти:
* Проверить, не созданы ли случайные глобальные переменные.
* В случае явно созданных глобальных переменных нужно убедиться, что по завершению их использования, их значение будет переведено в `null` или переопределено.
* Проверить, назначены ли на таймеры события их очищения.

Инструменты:
* Chrome Dev Tools. Вкладки timeline и профили.

</p>
</details>

---

##### 13. Как устроен процесс сборки мусора в современных браузерах? Какой недостаток у сборщиков мусора?

<details><summary><b>Ответ</b></summary>
<p>

Современные браузеры оснащаются сборщиками мусора (**garbage collector**), работающими по принципу **mark-and-sweep (пометь и выброси)**.

Алгоритм работы:
1. Сборщик мусора строит список корневых объектов. В Javascript это window.
2. Сборщик рекурсивно обходит корни и их потомков, помечая их как активные (т.е. не мусор).
3. После второго шага фрагменты памяти, не помеченные как активные, могут считаться мусором. Теперь сборщик может освободить эту память и вернуть в ОС.

Недостаток сборщиков мусора: недетерминированность — это значит, что сборщики мусора непредсказуемы.
Обычно невозможно определить, когда будет сборка мусора, из-за чего программа иногда занимает больше памяти, чем требуется.

</p>
</details>

---

##### 14. Что такое LHS и RHS поиск движка?
<details><summary><b>Ответ</b></summary>
<p>

**LHS (Left Hand Side)** — левосторонний поиск по отношению к оператору `=`.

**RHS (Right Hand Side)** — правосторонний поиск по отношению к оператору `=`.

В зависимости от того, какую ссылку мы ищем, RHS или LHS, могут быть разные результаты.

Если был RHS поиск и переменная не найдена, то мы получим `ReferenceError`.

Если был RHS поиск, переменная найдена, но мы пытаемся сделать с ней что-то противоестественное (например, использовать не функцию, как функцию), то мы получим `TypeError`.

Если был LHS поиск и переменная не найдена: При `StrictMode` мы получим `ReferenceError`, в ином случае в глобальной области будет создана переменная с указанным именем и передана движку.

```js
console.log(a)      // RHS
a = 2               // LHS

function foo(a) {
  console.log(a)
}

foo(2)
// RHS при вызове foo()
// LHS при присваивании аргументу `a` значение `2`
```

Подробнее:
* [Вы не знаете JS. Области видимости и замыкания. Часть 1](https://medium.com/@Dimetrio89/вы-не-знаете-js-область-видимости-и-замыкания-часть-1-17f305c79785)

</p>
</details>

---

##### 15. Что такое поднятие (hoisting)?

<details><summary><b>Ответ</b></summary>
<p>

**Поднятие (hoisting)** – термин, который учит, что объявление переменной или функции физически перемещается в начало кода. В действительности это не так: во время создания контекста выполнения объявления переменных и функций записываются в память, но остаются в коде на том месте, где были объявлены. 

`var` — объявляет переменную и присваивает ей `undefined`.

`function` — объявляет функцию и инициализирует её (благодаря тому, как работает контекст выполнения).

`let`, `const`, `class` — только объявляет переменную.

</p>
</details>

---

##### 16. Что такое затенение переменных?

<details><summary><b>Ответ</b></summary>
<p>

**Затенение переменных** — когда переменная, объявленная в определенной области имеет то же имя, что и переменная, объявленная во внешней области.

```javascript
var currency = 'euro'

function showMeTheMoney() {
  var currency = 'ruble'
  console.log(currency)
}

showMeTheMoney()
```

</p>
</details>

---

##### 17. Что такое всплытие (Event Bubbling) и перехват событий (Event Capturing)?

<details><summary><b>Ответ</b></summary>
<p>

При возникновении события, Javascript проходит три стадии:
1. Стадия перехвата — порядок, при котором события на элементах проверяются сверху вниз.
2. Стадия цели — когда событие достигло целевого элемента.
3. Стадия всплытия — порядок, при котором обработчики события проверяются снизу вверх.

Обработчики, добавленные через `on...`-свойство, ничего не знают о стадии перехвата, а начинают работать со всплытия.

Чтобы поймать событие на стадии перехвата, нужно третий аргумент `addEventListener` выставить в значение `true`.

</p>
</details>

---

##### 18. В чем отличие между `e.target` и `e.currentTarget`?

<details><summary><b>Ответ</b></summary>
<p>

`e.target` — это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен.

`e.currentTarget` — это текущий элемент, до которого дошло всплытие.

```html
<div id="container">
  <div id="video">
    <button id="button">Play!</button>
  </div>
</div>
```

```javascript
container.addEventListener('click', fn);
video.addEventListener('click', fn);
button.addEventListener('click', fn);

function fn(e) {
  console.log(e.target, e.currentTarget);
}
```

В консоль будет выведено:
```html
<button id="button">Play!</button>
<button id="button">Play!</button>

<button id="button">Play!</button>
<div id="video"></div>

<button id="button">Play!</button>
<div id="container"></div>
```

</p>
</details>

---

##### 19. Что такое область видимости (scope)?

<details><summary><b>Ответ</b></summary>
<p>

**Область видимости (scope)** — объект, который определяет доступность (видимость) переменных и функций.

Есть два вида области видимости:
* Глобальная область видимости — переменные, содержащиеся в ней доступны в любом месте программы.
* Локальная область видимости — переменные, содержащиеся в локальной области видимости доступны только в ней.

**[[Scope]]** - это скрытое внутреннее свойство функции, которое она получает во время вызова. Данное свойство содержит ссылку на ту область видимости, в которой данная функция была объявлена.

* [JavaScript Scope](https://www.w3schools.com/js/js_scope.asp)

</p>
</details>

---


##### 20. Что такое VariableEnvironment?

<details><summary><b>Ответ</b></summary>
<p>

**VariableEnvironment** — объект, который хранит переменные окружения, в котором он находится.

* [JavaScript/TypeScript Internals: Execution vs. Lexical vs. Variable Environment](https://medium.com/@bdov_/javascript-typescript-execution-vs-lexical-vs-variable-environment-37ff3f264831)

</p>
</details>

---

Ссылки:
* [Замыкания, функции изнутри](https://learn.javascript.ru/closures)
* [Контекст выполнения и стек вызовов в Javascript](https://habr.com/ru/company/ruvds/blog/422089/)
* [Вы не знаете JS. Области видимости и замыкания. Часть 1](https://medium.com/@Dimetrio89/вы-не-знаете-js-область-видимости-и-замыкания-часть-1-17f305c79785)
* [Управление памятью](https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management)
* [4 вида утечек памяти в JavaScript и как с ними бороться](https://habr.com/ru/post/309318/)
* [Поднятие](https://developer.mozilla.org/ru/docs/Словарь/Поднятие)
* [JavaScript/TypeScript Internals: Execution vs. Lexical vs. Variable Environment](https://medium.com/@bdov_/javascript-typescript-execution-vs-lexical-vs-variable-environment-37ff3f264831)
