<div align="center">

<h1>Javascript. Вопросы по алгоритмам и оптимизации</h1>

<a href="https://github.com/dollaween/javascript-questions">На главную</a> | <a href="https://github.com/dollaween/javascript-tests">Тесты</a> | <a href="https://github.com/dollaween/javascript-tasks">Задачи</a>

</div>

---

##### 1. У нас есть большая макрозадача по перебору 1e9 элементов таблицы. С какими трудностями можно столкнуться и как их решить?
```js
let i = 0

const fn = () => {
  for (let k = 0; k < 1e9; k++) {
    i++
  }
  console.log('finish!')
}

fn()
```
<details><summary><b>Ответ</b></summary>
<p>

Пока движок занят перебором элементов, он не может делать ничего связанного с DOM, не может обрабатывать пользовательские события и т.д.

Для оптимизации такой задачи её нужно разбить на несколько задач. Теперь, если новая сторонняя задача появляется (например, событие `onclick`), пока движок занят выполнением первой части, то она становится в очередь и будет выполнена, когда первая часть будет завершена.

```js
let i = 0

const fn = () => {
  if (i < 1e9 - 1e6) {
    setTimeout(fn)
  }

  do {
    i++
  } while (i % 1e6 != 0)

  if (i == 1e9) {
    console.log('finish!')
  }
}

fn()
```

При такой реализации вызов `setTimeout` лучше выносить вверх, так как у браузера есть минимальная задержка в 4 миллисекунды при множестве вложенных вызовов `setTimeout`. Поэтому чем раньше мы запланируем выполнение — тем быстрее выполнится код.

</p>
</details>

---

##### 2. Как разбить долгую макротаску (`CPU bound` операцию)?
<details><summary><b>Ответ</b></summary>
<p>

1. Если во время операции мы изменяем `DOM`, то используем `requestAnimationFrame`
2. Если задача неприоритетная, недолгая и не тяжелая, которая будет не слишком нагружать CPU, то используем `requestIdleCallback`
3. Если у нас большая мощная задача, которую надо исполнять постоянно, тогда используем WebWorkers. Другого выхода нет

[Иван Тулуп: асинхронщина в JS под капотом](https://habr.com/ru/company/oleg-bunin/blog/417461/)

</p>
</details>

---

##### 3. Что такое нотация О большое (Big O notation)?

<details><summary><b>Ответ</b></summary>
<p>

Нотация О большое — это математическая нотация, которая описывает ограничивающее поведение функции, когда аргумент стремится к определенному значению или бесконечности. Проще говоря, нотация О большое описывает сложность написанного кода с использованием алгебраических терминов.

Концепцию О большое необходимо понимать, чтобы уметь видеть и исправлять неоптимальный код.

##### Отбрасывание констант
Big O описывает только темп роста функции, поэтому мы отбрасываем константы при оценке сложности:
* `O(2N)` должен описываться как `O(N)`
* `O(N/2) = O(N)`
* `O(N^2 + 100) = O(N^2)`

##### Неважная сложность
Мы можем сокращать описание сложности, убирая из формулы неважную сложность. Неважной считается сложность, которая значительно меньше уже имеющейся сложности (где значительно — это минимум в 2 раза)
* `O(N^2 + N^2) = O(N^2)`
* `O(N^2 + N) = O(N^2)` — так как `N` значительно меньше чем `N^2`
* `O(N + log N) = O(N)`, так как `log N` значительно меньше чем `N`
* `O(5 * 2^N + 10 * N^100) = O(2^N)`
* `O(N^2 + B) = O(N^2 + B)` — не может быть сокращено, так как мы не знаем что такое `B`

##### Складывать или умножать сложность?
Если действия выполняются последовательно — то складываем:
```js
for (int a: arrA) {}
for (int b: arrB) {}
// O(A + B)
```

Если действия зависимы друг от друга — то умножаем:
```js
for (int a: arrA) {
  for (int b: arrB) {}
}
// O(A * B)
```

##### Про сложность `log N`
Для алгоритмов, где на каждой итерации берется половина элементов — сложность будет включать `O(log N)` (включать, но не обязательно равняться).

[Оценка сложности алгоритма. Сложность алгоритмов. Big O, Большое О](https://www.youtube.com/watch?v=ZRdOb4yR0kk&ab_channel=CronisAcademy)

</p>
</details>
