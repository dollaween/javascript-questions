# Javascript-вопросы: Оптимизация

---

##### 1. У нас есть большая макрозадача по перебору 1e9 элементов таблицы. С какими трудностями можно столкнуться и как их решить?
```js
let i = 0

const fn = () => {
  for (let k = 0; k < 1e9; k++) {
    i++
  }
  console.log('finish!')
}

fn()
```
<details><summary><b>Ответ</b></summary>
<p>

Пока движок занят перебором элементов, он не может делать ничего связанного с DOM, не может обрабатывать пользовательские события и т.д.

Для оптимизации такой задачи её нужно разбить на несколько задач. Теперь, если новая сторонняя задача появляется (например, событие `onclick`), пока движок занят выполнением первой части, то она становится в очередь и будет выполнена, когда первая часть будет завершена.

```js
let i = 0

const fn = () => {
  if (i < 1e9 - 1e6) {
    setTimeout(fn)
  }

  do {
    i++
  } while (i % 1e6 != 0)

  if (i == 1e9) {
    console.log('finish!')
  }
}

fn()
```

При такой реализации вызов `setTimeout` лучше выносить вверх, так как у браузера есть минимальная задержка в 4 миллисекунды при множестве вложенных вызовов `setTimeout`. Поэтому чем раньше мы запланируем выполнение — тем быстрее выполнится код.

</p>
</details>

---

##### 2. Как разбить долгую `CPU bound` операцию?
<details><summary><b>Ответ</b></summary>
<p>

1. Если во время операции мы изменяем `DOM`, то используем `requestAnimationFrame`
2. Если задача неприоритетная, недолгая и не тяжелая, которая будет не слишком нагружать CPU, то используем `requestIdleCallback`
3. Если у нас большая мощная задача, которую надо исполнять постоянно, тогда используем WebWorkers. Другого выхода нет

[Иван Тулуп: асинхронщина в JS под капотом](https://habr.com/ru/company/oleg-bunin/blog/417461/)

</p>
</details>

