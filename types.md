<div align="center">

# Вопросы по переменным и типам

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)

</div>

---

##### 1. Какие типы данных есть в Javascript?

<details><summary><b>Ответ</b></summary>
<p>

Примитивы (это данные, которые не являются объектами и не имеют методов):
* `string`
* `number`
* `boolean`
* `undefined`
* `null`
* `symbol`
* `bigint`

Сложные:
* `object`
* `function`

</p>
</details>

---

##### 2. Что такое `undeclared` и `undefined` переменные?

<details><summary><b>Ответ</b></summary>
<p>

`undeclared` — не объявленные переменные, которых не существует в программе.

`undefined` — объявленные переменные, которым не присвоено значение.

</p>
</details>

---

##### 3. Что такое `null` и какие у него проблемы?

<details><summary><b>Ответ</b></summary>
<p>

Значение `null` представляет отсутствие какого-либо значения.
В контексте логических операций рассматривается как `false`.

Из-за давней ошибки в языке `typeof null === 'object'`

</p>
</details>

---

##### 4. Что такое глобальные объекты и какие у них проблемы?
<details><summary><b>Ответ</b></summary>
<p>

Глобальные объекты — переменные и функции, доступные в любом месте программы. В браузере это `window`, в Node.js это `global`.

Проблемы:
* Все глобальные объекты находятся в одном глобальном пространстве имен, из-за чего всегда есть вероятность конфликта имен — когда две различные части приложения определяют глобальные переменные с одинаковым именем, но для разных целей
* При встраивании стороннего кода также есть вероятность конфликта имен

</p>
</details>

---

##### 5. Что вызывает и как происходит явное и неявное приведение к типу String?
<details><summary><b>Ответ</b></summary>
<p>

Явное преобразование — происходит через функцию `String()`.

Неявное преобразование — происходит при использовании оператора сложения `+`, если один из операндов является строкой.

```js
String(123)  // явное преобразование
123 + ''     // неявное преобразование
```

Примеры:
```js
String(123)            // '123'
String(-12.3)          // '-12.3'
String(null)           // 'null'
String(undefined)      // 'undefined'
String(true)           // 'true'
String(false)          // 'false'
String(Symbol('sym'))  // 'Symbol(sym)'
'' + Symbol('sym')     // ошибка TypeError
```

</p>
</details>

---

##### 6. Что вызывает и как происходит явное и неявное приведение к типу Boolean?
<details><summary><b>Ответ</b></summary>
<p>

Явное преобразование — происходит через функцию `Boolean()`.

Неявное преобразование — происходит в логическом контексте или вызывается логическими операторами `||`, `&&`, `!`.

```js
Boolean(5)     // явное преобразоване
if (5) {}      // неявное преобразование в логическом контексте
5 ? ... : ...  // неявное преобразование в логическом контексте
!!5            // неявное преобразование логическим оператором
5 || 'Hello'   // неявное преобразование логическим оператором
```

Выражения, которые выдают `false`:
```js
Boolean('')         // false
Boolean(0)          // false
Boolean(-0)         // false
Boolean(NaN)        // false
Boolean(null)       // false
Boolean(undefined)  // false
Boolean(false)      // false
```

Все остальные значения будут конвертироваться в `true`:
```js
Boolean({})             // true
Boolean([])             // true
Boolean(Symbol())       // true
!!Symbol()              // true
Boolean(function() {})  // true
```

</p>
</details>

---

##### 7. Что вызывает и как происходит явное и неявное приведение к типу Number?
<details><summary><b>Ответ</b></summary>
<p>

Явное преобразование — происходит через функцию `Number()`.

Неявное преобразование — происходит при помощи следующих операторов:
* Операторы сравнения `>`, `<`, `<=`, `>=`.
* Побитовые операторы `|`, `&`, `^`, `~`.
* Арифметические операторы `-`, `+`, `*`, `/`, `%`. Оператор `+` не вызывает неявное преобразование, если хотя бы один из операндом является строкой.
* Унарный оператор `+`.
* Оператор нестрогого равенства `==`, `!=`. Оператор `==` не вызывает неявное преобразование, если оба операнда являются строками.

```js
Number('123')  // явное преобразование
+'123'         // неявное преобразование
123 != '456'   // неявное преобразование
4 > '5'        // неявное преобразование
5 / null       // неявное преобразование
true | 0       // неявное преобразование
```

Примеры:
```js
Number(null)           // 0
Number(undefined)      // NaN
Number(true)           // 1
Number(false)          // 0
Number(' 12 ')         // 12
Number('-12.34')       // -12.34
Number('\n')           // 0
Number(' 12s ')        // NaN
Number(123)            // 123
Number(Symbol('sym'))  // ошибка TypeError
+Symbol('123')         // ошибка TypeError
```

При преобразовании строк в числа система сначала обрезает пробелы, а также символы `\n` и `\t`, находящиеся в начале и конце строки, и возвращает `NaN`, если полученная строка не является действительным числом. Если строка пуста — возвращается `0`.

Значения типа `Symbol` не могут быть преобразованы ни явно, ни неявно.

При применении оператора `==` к `null` или `undefined` преобразования в число не производится.

```js
null == 0       // false
undefined == 0  // false
```

Значение `NaN` не равно ничему, включая себя.

</p>
</details>

---

Источники:
* [Неявное преобразование типов в JavaScript](https://habr.com/ru/company/ruvds/blog/347866/)
