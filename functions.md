<div align="center">

<h1>Javascript. Вопросы по функциям</h1>

<a href="https://github.com/dollaween/javascript-questions">На главную</a> | <a href="https://github.com/dollaween/javascript-tests">Тесты</a> | <a href="https://github.com/dollaween/javascript-tasks">Задачи</a>

</div>

---

##### 1. Что такое частичное применение функций?
<details><summary><b>Ответ</b></summary>
<p>

**Частичное применение функций** — предоставление функции меньшего количества аргументов, чем она ожидает.

[Частичное применение функций](https://medium.com/devschacht/functional-reactive-ninja-partial-application-of-functions-99fc21d629ff)

</p>
</details>

---

##### 2. Что такое цепь вызовов (method chaining)?
<details><summary><b>Ответ</b></summary>
<p>

**Цепь вызовов** — конструкция, при которой вызов одного метода следует сразу за вызовом другого.

```js
'Hello'.replace(/Hello/g, 'Bye').concat('!')
```

</p>
</details>

---

##### 3. Что такое рекурсия?
<details><summary><b>Ответ</b></summary>
<p>

**Рекурсия** — это когда функция вызывает саму себя.

Примеры, где используется рекурсия:
* JSON.parse / JSON.stringify (Mozilla's Rhino JsonParser)
* document.getElementById и обход дерева DOM
* Обход объектов

Рецепт написания рекурсии:
1. Написать условие выхода из рекурсии
2. ...какое-либо изменение...
3. Написать вызов функции самой себя

##### Паттерн чистой рекурсии

```js
function recursion(args) {
  // Условие выхода
  return recursion(args--)
}
```

##### Паттерн рекурсивной функции внутри функции-обёртки
Более легкий паттерн, с использованием переменной извне рекурсии.

```js
function wrapper(args) {
  let scope = {}

  function recursion(args) {
    // Пишем условие выхода
    // Изменяем scope
    recursion(args--)
  }

  recursion()

  return scope
}
```

##### Пример
Пример рекурсивной функции, где высчитывается сумма всех чисел от 1 до указанного:
```js
function sumNumbers(num) {
  if (num === 1) return 1

  return num + sumNumbers(num - 1)
}

const result = sumNumbers(5)
console.log(result)
// => 15, так как 1 + 2 + 3 + 4 + 5 === 15
```

</p>
</details>

---

##### 4. Что такое анонимная функция?
<details><summary><b>Ответ</b></summary>
<p>

**Анонимная функция** — это функция, у которой после `function` нет идентификатора.

Примеры анонимных функций:
```js
function() {}
const myFunc1 = function() {}
const myFunc2 = new Function() 
const myObject = {
  methodD(){},
  [property](){}
}
```

Стрелочные функции всегда анонимны.
```js
() => {}
```

Анонимная функция может иметь имя, но при этом все равно являться анонимной:
```js
const myFunc = function() { }
console.log(myFunc.name)        // `myFunc`
```

</p>
</details>

---

##### 5. Что такое "Немедленно вызываемая функция" (IIFE)?
<details><summary><b>Ответ</b></summary>
<p>

**Немедленно вызываемая функция (IIFE)** — это конструкция, позволяющая вызвать функцию сразу после её объявления.

Конструкция состоит из двух частей:
1. Функция, заключенная в оператор группировки `()`. Благодаря этому переменные IIFE замыкаются в его пределах и глобальная область видимости ими не засоряется.
2. Мгновенно выполняющееся функциональное выражение `()`, благодаря которому движок выполняет функцию напрямую.

```js
(function() {
  // code
})()
```

Переменные, внутри функции не могут быть использованы за её пределами:
```js
(function() {
  var name = 'dollaween'
})()
name // throws "Uncaught ReferenceError: name is not defined"
```

Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию:
```js
var result = (function () {
  return 'dollaween'
})()
result // 'dollaween'
```

</p>
</details>

---

##### 6. Что такое чистая функция?
<details><summary><b>Ответ</b></summary>
<p>

**Чистая функция** — это функция, которая:
1. Является детерминированной — для одного и того же набора входных значений функция возвращает одинаковый результат.
2. Не обладает побочными эффектами — выполнение функции не изменяет какое-либо состояние за пределами её области видимости и не оказывает видимого воздействия на внешний мир, кроме возвращения значения.

Пример чистой функции:
```js
function add(a, b) {
  return a + b
}
```

Пример не чистой функции:
```js
function getRandom() {
  return Math.random()
}
```

</p>
</details>

---

##### 7. Чем стрелочная функция отличается от обычной?
<details><summary><b>Ответ</b></summary>
<p>

1. Стрелочные функции всегда анонимны.
2. Стрелочные функции не содержат собственного контекста `this`, а используют значение `this` окружающего контекста.
3. Так как значение `this` определяется лексикой, вызов стрелочных функций с помощью методов `call()` и `apply()` не влияет на значение `this` (даже при передаче аргументов).
4. Стрелочные функции не имеют собственного объекта `arguments`, поэтому в теле стрелочных функций `arguments` будет ссылаться на переменную в окружающей области.
5. Стрелочные функции не могут быть использованы как конструктор и вызовут ошибку при использовании с `new`.
6. Ключевое слово yield не может быть использовано в теле стрелочной функции (за исключением случаев, когда разрешается использовать в функциях, вложенных в тело стрелочной функции). Как следствие стрелочные функции не могут быть использованы как генераторы.

</p>
</details>

---

##### 8. Что такое `arguments`?
<details><summary><b>Ответ</b></summary>
<p>

`arguments` — это подобный массиву объект, который содержит аргументы, передынные в функцию. "Подобный массиву" означает, что `arguments` имеет свойство `length`, а элементы индексируются начиная с нуля. Но при этом он не может обращаться ко встроенным методам массивов.

`arguments` можно преобразовать в массив:
```js
const args = Array.prototype.slice.call(arguments)
const args = [].slice.call(arguments)
const args = Array.from(arguments)
const args = [...arguments]
```

*Вместо `arguments` предпочтительнее использовать rest параметры*.

</p>
</details>

---

##### 9. В чем отличие между методами `bind()`, `call()` и `apply()`?
<details><summary><b>Ответ</b></summary>
<p>

`bind()` — создает новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передается набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

`call()` — вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.

`apply()` — вызывает функцию с указанным значением `this` и аргументами, предоставленными в виде массива (либо массивоподобного объекта).

```js
const newThis = {}
fn.call(newThis, arg1, arg2, ...)
fn.apply(newThis, [arg1, arg2, ...])
fn.bind(newThis, arg1, arg2, ...)
```

</p>
</details>

---

##### 10. Что такое каррирование (currying)?
<details><summary><b>Ответ</b></summary>
<p>

**Каррирование или карринг (currying)** — это преобразование функции со множеством аргументов в набор вложенных функций с одним аргументом. Простыми словами — это трансформация функции таким образом, чтобы она принимала аргументы не как `func(a, b, c)`, а как `func(a)(b)(c)`.

Пример реализации:
```js
function volume(l) {
  return (w) => {
    return (h) => {
      return l * w * h
    }
  }
}

const vol = volume(100)(20)(90)
```

При помощи каррирования можно реализовать концепт частичного применения функции (зафиксировать некоторые аргументы):
```js
function volume(l) {
  return (w, h) => {
    return l * w * h
  }
}

const hV = volume(70)

// Теперь первый аргумент зафиксирован и мы работаем только с оставшимися:
hV(203, 142)

// Либо можем использовать вызов функции таким образом:
volume(70)(90, 30)
```

* [Каррирование функций в JavaScript](https://habr.com/ru/company/ruvds/blog/427295/)
* [Каррирование](https://learn.javascript.ru/currying-partials)

</p>
</details>

---
