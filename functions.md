<div align="center">

<h1>Javascript. Вопросы по функциям</h1>

<a href="https://github.com/dollaween/javascript-questions">На главную</a> | <a href="https://github.com/dollaween/javascript-tests">Тесты</a> | <a href="https://github.com/dollaween/javascript-tasks">Задачи</a>

</div>

---

##### 1. Что такое частичное применение функций (Partial Application)?
<details><summary><b>Ответ</b></summary>
<p>

**Частичное применение функций (Partial Application)** — это применение к функции некоторых аргументов и возврат новой функции, в ожидании остальных аргументов.

С помощью каррирования мы можем добиться подобного эффекта путем фиксирования нескольких входных параметров:
```js
function volume(l) {
  return (w, h) => {
    return l * w * h
  }
}

const hV = volume(70)

// Теперь первый аргумент зафиксирован. Это и есть частичное применение функции, так как нам больше не нужно указывать все три параметра:
hV(203, 142)
```

Также подобного эффекта можно добиться через `bind()`:
```js
const multiply = (x, y) => x * y
const multiply2 = multiply.bind(null, 2)

console.log(multiply2(3)) // 6
```

* [Частичное применение функций](https://medium.com/devschacht/functional-reactive-ninja-partial-application-of-functions-99fc21d629ff)
* [Частичное применение или partial application в JavaScript](https://frontend-stuff.com/blog/partial-application/)

</p>
</details>

---

##### 2. Что такое цепь вызовов (method chaining)?
<details><summary><b>Ответ</b></summary>
<p>

**Цепь вызовов** — конструкция, при которой вызов одного метода следует сразу за вызовом другого.

```js
'Hello'.replace(/Hello/g, 'Bye').toLowerCase()
```

Для создания цепи вызовов нужно чтобы каждая функция по завершению своей работы возвращала совместимый тип данных/объект необходимый для работы следующей функции.

Пример выше работает, потому что для работы `replace()` нужна строка, а `Hello` является строкой. После выполнения `replace()` возвращает строку, а для работы `toLowerCase()` как раз нужна строка.

Пример создания цепи вызовов на основе объекта:
```js
const counter = {
  count: 0,
  add() {
    this.count++
    return this
  },
  sub() {
    this.count--
    return this
  },
  log() {
    console.log(this.count)
    return this
  }
}

counter.add().sub().sub().add().add().log() // 1
```

</p>
</details>

---

##### 3. Что такое рекурсия?
<details><summary><b>Ответ</b></summary>
<p>

**Рекурсия** — это когда функция вызывает саму себя.

Примеры, где используется рекурсия:
* JSON.parse / JSON.stringify (Mozilla's Rhino JsonParser)
* document.getElementById и обход дерева DOM
* Обход объектов

Рецепт написания рекурсии:
1. Написать условие выхода из рекурсии
2. ...какое-либо изменение...
3. Написать вызов функции самой себя

##### Паттерн чистой рекурсии

```js
function recursion(args) {
  // Условие выхода
  return recursion(args--)
}
```

##### Паттерн рекурсивной функции внутри функции-обёртки
Более легкий паттерн, с использованием переменной извне рекурсии.

```js
function wrapper(args) {
  let scope = {}

  function recursion(args) {
    // Пишем условие выхода
    // Изменяем scope
    recursion(args--)
  }

  recursion()

  return scope
}
```

##### Пример
Пример рекурсивной функции, где высчитывается сумма всех чисел от 1 до указанного:
```js
function sumNumbers(num) {
  if (num === 1) return 1

  return num + sumNumbers(num - 1)
}

const result = sumNumbers(5)
console.log(result)
// => 15, так как 1 + 2 + 3 + 4 + 5 === 15
```

</p>
</details>

---

##### 4. Что такое анонимная функция?
<details><summary><b>Ответ</b></summary>
<p>

**Анонимная функция** — это функция, у которой после `function` нет идентификатора.

Примеры анонимных функций:
```js
function() {}
const myFunc1 = function() {}
const myFunc2 = new Function() 
const myObject = {
  methodD(){},
  [property](){}
}
```

Стрелочные функции всегда анонимны.
```js
() => {}
```

Анонимная функция может иметь имя, но при этом все равно являться анонимной:
```js
const myFunc = function() { }
console.log(myFunc.name)        // `myFunc`
```

</p>
</details>

---

##### 5. Что такое "Немедленно вызываемая функция" (IIFE)?
<details><summary><b>Ответ</b></summary>
<p>

**Немедленно вызываемая функция (IIFE)** — это конструкция, позволяющая вызвать функцию сразу после её объявления.

Конструкция состоит из двух частей:
1. Функция, заключенная в оператор группировки `()`. Благодаря этому переменные IIFE замыкаются в его пределах и глобальная область видимости ими не засоряется.
2. Мгновенно выполняющееся функциональное выражение `()`, благодаря которому движок выполняет функцию напрямую.

```js
(function() {
  // code
})()
```

Переменные, внутри функции не могут быть использованы за её пределами:
```js
(function() {
  var name = 'dollaween'
})()
name // throws "Uncaught ReferenceError: name is not defined"
```

Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию:
```js
var result = (function () {
  return 'dollaween'
})()
result // 'dollaween'
```

</p>
</details>

---

##### 6. Что такое чистая функция?
<details><summary><b>Ответ</b></summary>
<p>

**Чистая функция** — это функция, которая:
1. Является детерминированной — для одного и того же набора входных значений функция возвращает одинаковый результат.
2. Не обладает побочными эффектами — выполнение функции не изменяет какое-либо состояние за пределами её области видимости и не оказывает видимого воздействия на внешний мир, кроме возвращения значения.

Пример чистой функции:
```js
function add(a, b) {
  return a + b
}
```

Пример не чистой функции:
```js
function getRandom() {
  return Math.random()
}
```

</p>
</details>

---

##### 7. Чем стрелочная функция отличается от обычной?
<details><summary><b>Ответ</b></summary>
<p>

1. Стрелочные функции всегда анонимны.
2. Стрелочные функции не содержат собственного контекста `this`, а используют значение `this` окружающего контекста.
3. Так как значение `this` определяется лексикой, вызов стрелочных функций с помощью методов `call()` и `apply()` не влияет на значение `this` (даже при передаче аргументов).
4. Стрелочные функции не имеют собственного объекта `arguments`, поэтому в теле стрелочных функций `arguments` будет ссылаться на переменную в окружающей области.
5. Стрелочные функции не могут быть использованы как конструктор и вызовут ошибку при использовании с `new`.
6. Ключевое слово yield не может быть использовано в теле стрелочной функции (за исключением случаев, когда разрешается использовать в функциях, вложенных в тело стрелочной функции). Как следствие стрелочные функции не могут быть использованы как генераторы.

</p>
</details>

---

##### 8. Что такое `arguments`?
<details><summary><b>Ответ</b></summary>
<p>

`arguments` — это подобный массиву объект, который содержит аргументы, передынные в функцию. "Подобный массиву" означает, что `arguments` имеет свойство `length`, а элементы индексируются начиная с нуля. Но при этом он не может обращаться ко встроенным методам массивов.

`arguments` можно преобразовать в массив:
```js
const args = Array.prototype.slice.call(arguments)
const args = [].slice.call(arguments)
const args = Array.from(arguments)
const args = [...arguments]
```

*Вместо `arguments` предпочтительнее использовать rest параметры*.

</p>
</details>

---

##### 9. В чем отличие между методами `bind()`, `call()` и `apply()`?
<details><summary><b>Ответ</b></summary>
<p>

`bind()` — создает новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передается набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

`call()` — вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.

`apply()` — вызывает функцию с указанным значением `this` и аргументами, предоставленными в виде массива (либо массивоподобного объекта).

```js
const newThis = {}
fn.call(newThis, arg1, arg2, ...)
fn.apply(newThis, [arg1, arg2, ...])
fn.bind(newThis, arg1, arg2, ...)
```

</p>
</details>

---

##### 10. Что такое каррирование (currying)?
<details><summary><b>Ответ</b></summary>
<p>

**Каррирование или карринг (currying)** — это преобразование функции со множеством аргументов в набор вложенных функций с одним аргументом. Простыми словами — это трансформация функции таким образом, чтобы она принимала аргументы не как `func(a, b, c)`, а как `func(a)(b)(c)`.

Пример реализации:
```js
function volume(l) {
  return (w) => {
    return (h) => {
      return l * w * h
    }
  }
}

const vol = volume(100)(20)(90)
```

При помощи каррирования можно реализовать концепт частичного применения функции (зафиксировать некоторые аргументы):
```js
function volume(l) {
  return (w, h) => {
    return l * w * h
  }
}

const hV = volume(70)

// Теперь первый аргумент зафиксирован и мы работаем только с оставшимися:
hV(203, 142)

// Либо можем использовать вызов функции таким образом:
volume(70)(90, 30)
```

* [Каррирование функций в JavaScript](https://habr.com/ru/company/ruvds/blog/427295/)
* [Каррирование](https://learn.javascript.ru/currying-partials)

</p>
</details>

---

##### 11. Что такое функцмя-генератор?
<details><summary><b>Ответ</b></summary>
<p>

**Функция-генератор** — это функция, которая может приостанавливать свое выполнение, возвращать промежуточный результат и далее возобновлять свое выполнение в произвольный момент времени.

Функцию-генератор используют разные библиотеки, как замену `async/await` для работы с асинхронными операциями. Сам `async/await` — это hight level абстракция над генераторами.

##### Как работает:
Когда вызывается функция-генератор, её тело исполняется не сразу; вместо этого возвращается объект-итератор. При вызове метода `next()` объекта-итератора, тело функции-генератора исполняется до первого встреченного оператора `yield`, который определяет возвращаемое значение или делегирует дальнейшее выполнение другому генератору при помощи `yield* anotherGenerator()`.

Метод `next()` возвращает объект со свойством `value`, содержащим отданное значение, и свойством `done`, которое указывает, что генератор уже отдал свое последнее значение.

Вызов метода `next()` с аргументом прекращает выполнение функции-генератора, и заменяет инструкцию `yield`, на которой было приостановлено выполнение, на аргумент переданный в `next()`.

Пример:
```js
function* counter() {
  let index = 0
  while (index < 3)
    yield index++
}

const gen = counter()

console.log(gen.next().value) // 0
console.log(gen.next().value) // 1
console.log(gen.next().value) // 2
console.log(gen.next().value) // undefined
```

</p>
</details>

---
